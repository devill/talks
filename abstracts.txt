BIO
===

Rafael is a Lead Developer at Budapest-based Emarsys and popular speaker in the Hungarian software community.
As a founding member of Emarsys CraftLab - the dedicated coaching team of Emarsys - he has taught university
courses and lectured at numerous conferences. His passion for short feedback loops drove him to create Lean Poker,
a workshop where developers have the opportunity to experiment with continuous delivery in an artificial environment.


Lean Poker
==========

Lean Poker is this: you and a small group of strangers are going to develop a bot in a language of your choice, that
plays poker against other bots. (Don't worry if you don't know poker, we will teach you.) All you need to do is write
a function that takes a data structure containing cards and bets your bot sees during the game, and return a single
number: the amount you are willing to bet at that point.

Now here is the catch: even before you start coding the bots play a round in a matter of seconds, and if your bot wins
you get points. If it comes second, you get less points. Otherwise you get nothing. The next minute another game plays,
and another one, and another one… that goes on all day long, while you and your friends are desperately hacking away on
the code, and keep deploying, deploying, and deploying. Don’t worry about the deployment pipeline, that’s already set
up for you.

During this pretty intense day you will sometimes be cheering for your bot to take over, you will be deploying
desperately to change the course of events when your bot keeps losing, but even more importantly you will learn how to
create as much value as you can in a short period of time, while you are mostly just having fun.

Please check out http://leanpoker.org for more information.


Clean persistence
=================

Separating the database layer from the rest of code has always been an important topic, yet more often than not
 web applications end up looking like huge wrappers around the database. Keeping your database related code
 nicely isolated is hard, and it's even harder with applications where most of the logic has to do with reading
 and writing data. We will look at common mistakes, testing, design patterns and polyglot persistence.


How I learned to love legacy code, and why you should, too!
===========================================================

For a long time I thought that working on a green field project was the best thing that could happen to a developer.
I would look at the nightmarish company codebase blaming the incompetence of the people who had worked on it
previously. If only they read more books or had better mentors - I complained, but I was wrong. Not because if
something generates revenue, then it should be loved! No... that's not a real excuse for bad code. There is a lot more
disturbing truth about legacy code, and we need to face it. We need to learn why and how to embrace technical debt.


Learning to fall
================

When people talk about advantages of microservices, easy scaling and resilience comes up frequently. What they don't
usually tell you, is that robustness does not come for free. If you don't put extra effort into gracefully failing
when one of your dependencies is down, microservices will only make your system even more brittle.

In my presentation I will recount our journey from an unreliable monolith to a robust set of microservices with a
special focus on architectural patterns that helped us along the way.

=====
PLANS
=====

A step beyond modules
=====================

The jury is in: breaking down your web monolith to microservices or feature services is a viable option to scale
an organization. Services add an extra abstraction layer beyond modules that is immensely useful in structuring
your codebase. Understanding the characteristics of this extra layer, finding the traps along the way, learning
the tools that come with it is necessary to take full advantage of this new abstraction. So let's explore what
clean code means in the microservices world!

Minimum viable team: testing your ideas alone
==============================================

So you have an idea for a great application, but not much money nor friends to help out. You already asked people
if they would be interested, and they were really supportive, but when it comes to coding you are all alone. For
a developer, who is used to working in a team, it can be really demanding to go through with even a moderately
sized project. You know how to be effective as a team, but the same practices seem to hold you back when you are alone.

In the last few years I started a number of projects alone and managed to build, deploy and validate (or invalidate)
them within weeks of starting the project, and all that as a hobby next to my day job. Taking a few of these projects
as examples, I will tell you what agile practices I hang on to and what I changed or replaced to boost my productivity.


SOLID microservices
===================

The SOLID principles of OOP are probably the most important guidelines we use in software design. We apply them at
both class level, and at component level. Lately microservces have been introduced as a new, even higher level
abstraction to decompose large system. Let's explore what implications SOLID principles may have on microservices.
Do these principles apply to them? Do microservices help you to stay SOLID at lower levels?


Free beer and immortality
=========================

If a politician promised free beer and immortality people would laugh at him. If he promises workplaces and cheap
natural gas for heating they applaud him. The ironic thing about this is that the "free" beer is way more realistic
than a workplace for everyone who wants to do manual labour. Immortality is not entirely impossible, but burning
fossil fuels mindlessly will definitely kill us pretty soon unless we stop. The key phrase here is "technological
singularity" and it's a lot closer then we care to believe. But how do we get there? How do we adapt our society?
Who is going to be the last person to work and what's going to be the last task he completes?


The most important concept in an innovation based society
=========================================================

Ever since computers became cheap humankind is on it's mission to automate everything. If your work is repetitive, 
and does not involve creativity there is good chance it is either already automated, or will be pretty soon. That also 
goes for certain parts of a more complex job. That is the reason developers write tools all the time: they are 
automating their own job as a way to improve their effectiveness. A consequence of this is that - unlike any time
before the 21th century - soon everyone will need to be involved in innovation: building something that has not been 
build before. If it was built before, then it's pointless to build it again, robots can do that for us.

This is a radically different society then we had before. Hierarchies break down, and orders become rudimentary: every
person becomes a decision maker. What is the single most important concept, that can drive a society like this one?
